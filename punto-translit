#!/usr/bin/env python3
"""
Transliterate selected text (Cyrillic <-> Latin).
Called by punto when LCtrl+LAlt+Pause is pressed.
Handles copy/paste with terminal detection.
"""

import subprocess
import sys
import os
import pwd
import time
import re

# Transliteration mappings
CYR_TO_LAT = {
    'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo',
    'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'j', 'к': 'k', 'л': 'l', 'м': 'm',
    'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
    'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'shch', 'ъ': '',
    'ы': 'y', 'ь': "'", 'э': 'e', 'ю': 'yu', 'я': 'ya',
    'А': 'A', 'Б': 'B', 'В': 'V', 'Г': 'G', 'Д': 'D', 'Е': 'E', 'Ё': 'Yo',
    'Ж': 'Zh', 'З': 'Z', 'И': 'I', 'Й': 'J', 'К': 'K', 'Л': 'L', 'М': 'M',
    'Н': 'N', 'О': 'O', 'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T', 'У': 'U',
    'Ф': 'F', 'Х': 'H', 'Ц': 'C', 'Ч': 'Ch', 'Ш': 'Sh', 'Щ': 'Shch', 'Ъ': '',
    'Ы': 'Y', 'Ь': "'", 'Э': 'E', 'Ю': 'Yu', 'Я': 'Ya'
}

# For Lat -> Cyr, we need to handle multi-character sequences first
LAT_TO_CYR_MULTI = {
    'shch': 'щ', 'Shch': 'Щ', 'SHCH': 'Щ',
    'yo': 'ё', 'Yo': 'Ё', 'YO': 'Ё',
    'zh': 'ж', 'Zh': 'Ж', 'ZH': 'Ж',
    'ch': 'ч', 'Ch': 'Ч', 'CH': 'Ч',
    'sh': 'ш', 'Sh': 'Ш', 'SH': 'Ш',
    'yu': 'ю', 'Yu': 'Ю', 'YU': 'Ю',
    'ya': 'я', 'Ya': 'Я', 'YA': 'Я',
}

LAT_TO_CYR_SINGLE = {
    'a': 'а', 'b': 'б', 'v': 'в', 'g': 'г', 'd': 'д', 'e': 'е',
    'z': 'з', 'i': 'и', 'j': 'й', 'k': 'к', 'l': 'л', 'm': 'м',
    'n': 'н', 'o': 'о', 'p': 'п', 'r': 'р', 's': 'с', 't': 'т', 'u': 'у',
    'f': 'ф', 'h': 'х', 'c': 'ц', 'y': 'ы',
    'A': 'А', 'B': 'Б', 'V': 'В', 'G': 'Г', 'D': 'Д', 'E': 'Е',
    'Z': 'З', 'I': 'И', 'J': 'Й', 'K': 'К', 'L': 'Л', 'M': 'М',
    'N': 'Н', 'O': 'О', 'P': 'П', 'R': 'Р', 'S': 'С', 'T': 'Т', 'U': 'У',
    'F': 'Ф', 'H': 'Х', 'C': 'Ц', 'Y': 'Ы',
    "'": 'ь'
}

def transliterate(text):
    # Count Cyrillic letters
    cyr_count = len(re.findall(r'[а-яА-ЯёЁ]', text))
    total_letters = len(re.findall(r'[a-zA-Zа-яА-ЯёЁ]', text))
    
    if total_letters == 0:
        return text
        
    if cyr_count / total_letters > 0.5:
        # Cyr -> Lat
        res = ""
        for char in text:
            res += CYR_TO_LAT.get(char, char)
        return res
    else:
        # Lat -> Cyr
        res = text
        # Replace multi-char sequences first
        for lat, cyr in LAT_TO_CYR_MULTI.items():
            res = res.replace(lat, cyr)
        # Replace single-char sequences
        final_res = ""
        for char in res:
            final_res += LAT_TO_CYR_SINGLE.get(char, char)
        return final_res

def get_active_user_env():
    """Find active GUI user and their DISPLAY/XAUTHORITY."""
    try:
        cmd = "loginctl list-sessions | grep 'seat0' | awk '{print $3}' | head -n 1"
        user = subprocess.getoutput(cmd).strip()
        if not user:
            user = subprocess.getoutput("who | grep '(:0)' | awk '{print $1}' | head -n 1").strip()
        
        if not user:
            return None, {}

        uid = pwd.getpwnam(user).pw_uid
        pid_cmd = f"pgrep -u {user} gnome-session | head -n 1"
        pid = subprocess.getoutput(pid_cmd).strip()
        
        env = os.environ.copy()
        env['USER'] = user
        env['HOME'] = pwd.getpwnam(user).pw_dir
        
        if pid:
            with open(f"/proc/{pid}/environ", "rb") as f:
                env_data = f.read().split(b'\0')
                for item in env_data:
                    if item.startswith(b"DISPLAY="):
                        env['DISPLAY'] = item.split(b'=', 1)[1].decode()
                    if item.startswith(b"XAUTHORITY="):
                        env['XAUTHORITY'] = item.split(b'=', 1)[1].decode()
        
        if 'DISPLAY' not in env:
            env['DISPLAY'] = ':0'
        if 'XAUTHORITY' not in env:
            env['XAUTHORITY'] = f"/run/user/{uid}/gdm/Xauthority"
            
        return user, env
    except Exception:
        return None, {}

def run_as_user(user, env, cmd):
    """Run command as specific user."""
    wrapper = ['sudo', '-u', user, 'env', 
               f"DISPLAY={env.get('DISPLAY', ':0')}",
               f"XAUTHORITY={env.get('XAUTHORITY', '')}"] + cmd
    try:
        proc = subprocess.Popen(wrapper, 
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        stdout, _ = proc.communicate()
        return stdout
    except Exception:
        return None

def is_terminal_window(user, env):
    """Check if active window is a terminal using xprop."""
    try:
        wid_result = subprocess.run(
            ['sudo', '-u', user, 'env', 
             f"DISPLAY={env.get('DISPLAY', ':0')}",
             f"XAUTHORITY={env.get('XAUTHORITY', '')}",
             'xdotool', 'getactivewindow'],
            capture_output=True, text=True, timeout=2
        )
        if wid_result.returncode != 0:
            return False
            
        wid = wid_result.stdout.strip()
        
        result = subprocess.run(
            ['sudo', '-u', user, 'env', 
             f"DISPLAY={env.get('DISPLAY', ':0')}",
             f"XAUTHORITY={env.get('XAUTHORITY', '')}",
             'xprop', '-id', wid, 'WM_CLASS'],
            capture_output=True, text=True, timeout=2
        )
        if result.returncode == 0:
            output = result.stdout.strip()
            classes = re.findall(r'"([^"]+)"', output)
            classes_lower = [c.lower() for c in classes]
            
            terminals = ['gnome-terminal', 'gnome-terminal-server', 'konsole', 
                        'xterm', 'urxvt', 'terminator', 'tilix', 'alacritty', 
                        'kitty', 'terminology', 'xfce4-terminal', 'mate-terminal']
            return any(term in classes_lower for term in terminals)
    except Exception:
        pass
    return False

def main():
    try:
        user, env = get_active_user_env()
        if not user:
            sys.exit(1)

        in_terminal = is_terminal_window(user, env)
        if in_terminal:
            copy_keys = 'ctrl+shift+c'
            paste_keys = 'ctrl+shift+v'
        else:
            copy_keys = 'ctrl+c'
            paste_keys = 'ctrl+v'

        if in_terminal:
            text_bytes = run_as_user(user, env, ['xclip', '-selection', 'primary', '-o'])
            if not text_bytes:
                sys.exit(0)
            
            text_len = len(text_bytes.decode('utf-8', errors='ignore'))
            for _ in range(text_len):
                run_as_user(user, env, ['xdotool', 'key', 'BackSpace'])
            time.sleep(0.1)
        else:
            run_as_user(user, env, ['xdotool', 'key', '--clearmodifiers', copy_keys])
            time.sleep(0.2)
            
            text_bytes = run_as_user(user, env, ['xclip', '-selection', 'clipboard', '-o'])
            if not text_bytes:
                sys.exit(0)

        text = text_bytes.decode('utf-8', errors='ignore')
        processed = transliterate(text)

        proc = subprocess.Popen(
            ['sudo', '-u', user, 'env', 
             f"DISPLAY={env.get('DISPLAY', ':0')}",
             f"XAUTHORITY={env.get('XAUTHORITY', '')}",
             'xsel', '--clipboard', '--input'],
            stdin=subprocess.PIPE,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        proc.communicate(input=processed.encode('utf-8'))
        time.sleep(0.1)
        
        run_as_user(user, env, ['xdotool', 'key', '--clearmodifiers', paste_keys])
        
    except Exception:
        pass

if __name__ == '__main__':
    main()
